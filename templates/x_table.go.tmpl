// Code generated by LUSH modelgen. DO NOT EDIT.
package {{ .PackageName }}

import (
    "fmt"
    "strings"
	{{- range $k, $v:= .Table.Imports }}
	"{{$k}}"
	{{- end }}

    "github.com/LUSHDigital/modelgen"
)

// {{.Table.Name}}Column is a representation of a column in the {{ .Table.DBName }} table in the database
type {{.Table.Name}}Column string

const (
    {{.Table.Name}}SelectString = "{{ .Table.Fields | select_fields }}"
    {{.Table.Name}}DBName = "{{ .Table.DBName }}"
    {{- range $k, $v := .Table.Fields }}
    {{ $v.TableName }}{{ $v.Name }} = {{ $v.TableName }}Column("{{ $v.ColumnName }}")
    {{- end }}
)

var {{.Table.Name}}Columns = []{{.Table.Name}}Column{
    {{- range $k, $v:= .Table.Fields }}
    {{ $v.TableName }}{{ $v.Name }},
    {{- end }}
}

// {{.Table.Name}} represents a row in the {{.Table.DBName}} table
type {{.Table.Name}} struct {
    {{ range $k, $v:= .Table.Fields }}
        {{ $v.Name }} {{ $v.Type }} `json:"{{$v.ColumnName}}"`
    {{- end }}
}

// Build{{.Table.Name}}Select turns one or more {{.Table.Name}}Field into a string for select queries
func Build{{.Table.Name}}Select(columns []{{.Table.Name}}Column) string {
	return sqlbuilder.BuildSelect(columns)
}

// Scan{{.Table.Name}} will map a database row to its model struct
func Scan{{.Table.Name}}(scanner modelgen.Scanner, {{.ReceiverName}} *{{.Table.Name}}) error {
    return scanner.Scan({{ . | scan_fields}})
}

// Insert{{.Table.Name}} will insert a new {{.Table.Name}} row in the {{.Table.DBName}} table
{{- if has_int_pk .Table }}
func Insert{{.Table.Name}}(qu modelgen.Querier, {{.ReceiverName}} *{{.Table.Name}}) (lastInsertID int64, err error) {
{{- else  }}
func Insert{{.Table.Name}}(qu modelgen.Querier, {{.ReceiverName}} *{{.Table.Name}}) (err error) {
{{- end }}
    const stmt = "INSERT INTO {{.Table.DBName}} ({{.Table.Fields | insert_fields}}) VALUES ({{.Table.Fields | insert_values}})"
    {{- if has_int_pk .Table }}
    res, err := qu.Exec(stmt{{ . | insert_args }})
    if err != nil {
        return 0, err
    }
    return res.LastInsertId()
    {{- else  }}
    _, err = qu.Exec(stmt{{ . | insert_args }})
    return err
    {{- end }}
}

// Find{{.Table.Name}} will find a single single {{.Table.Name}} row in the {{.Table.DBName}} table based on its primary key
func Find{{.Table.Name}}(qu modelgen.Querier, {{.Table.PKName}} {{.Table.PKType}}) (*{{.Table.Name}}, error) {
    const stmt = "SELECT " + {{.Table.Name}}SelectString + " FROM {{.Table.DBName}} WHERE {{.Table.PKName}} = ?"
    var row = qu.QueryRow(stmt, {{.Table.PKName}})
    var {{.ReceiverName}} = &{{.Table.Name}}{}
    Scan{{.Table.Name}}(row, {{.ReceiverName}})
    return {{.ReceiverName}}, nil
}

// Load{{.Table.Name}} will load all or a subset of {{.Table.Name}} rows from the {{.Table.DBName}} table
func Load{{.Table.Name}}(qu modelgen.Querier, limit, offset int) (set []{{.Table.Name}}, err error) {
    const stmt = "SELECT " + {{.Table.Name}}SelectString + " FROM {{.Table.DBName}}"
    if limit == 0 && offset > 0 {
        err = fmt.Errorf("cannot query with offset but no limit")
        return
    }
    var sb strings.Builder
    sb.WriteString(stmt)

    if limit > 0 {
        sb.WriteString(fmt.Sprintf(" LIMIT %d", limit))
    }
    if offset > 0 {
        sb.WriteString(fmt.Sprintf(" OFFSET %d", offset))
    }

    rows, err := qu.Query(sb.String())
    if err != nil {
        return
    }
    defer rows.Close()

    for rows.Next() {
        var {{.ReceiverName}} {{.Table.Name}}
        if err = Scan{{.Table.Name}}(rows, &{{.ReceiverName}}); err != nil {
            return
        }
        set = append(set, {{.ReceiverName}})
    }

    return
}

// Delete{{.Table.Name}} an existing {{.Table.Name}} row from the {{.Table.DBName}} table
func Delete{{.Table.Name}}(qu modelgen.Querier, id int64) (rowsAffected int64, err error) {
    const stmt = "DELETE FROM {{.Table.DBName}} WHERE id = ?"
    result, err := qu.Exec(stmt, id)
	if err != nil {
		return
	}
	return result.RowsAffected()
}

// Count{{.Table.Name}} will coint the number of rows from the {{.Table.DBName}} table
func Count{{.Table.Name}}(qu modelgen.Querier) (count int64, err error) {
    const stmt = "SELECT COUNT(*) FROM {{.Table.DBName}}"
    row := qu.QueryRow(stmt)
    if err = row.Scan(&count); err != nil {
        return
    }
    return
}

// {{.Table.Name}}Exists checks for the items existence in the database, based on it's {{.Table.PKName}}
func {{.Table.Name}}Exists(qu modelgen.Querier, {{.Table.PKName}} {{.Table.PKType}}) (exists bool, err error) {
    const stmt = "SELECT EXISTS(SELECT 1 FROM {{.Table.DBName}} WHERE {{.Table.PKName}} = ? LIMIT 1) AS `exists`"
    var count int
    row := qu.QueryRow(stmt, {{.Table.PKName}})
    if err = row.Scan(&count); err != nil {
        return
    }
    return count > 0, nil
}
